# Chapter 05 - 안정 해시 설계

안정 해시는 수평적 규모 확장성(sacle out)을 달성하기 위해 데이터를 서버에 균등하게 나누는데 사용하는 기술.

## 해시 키 재배치(refresh) 문제

보편적으로 사용하는 해시 함수 `serverIndex = hash(key) % N ` (N은 서버의 개수) 를 사용하면 서버 풀(server pool)의 크기가 고정되어 있을 때, 그리고 데이터 분포가 균등할 때 잘 동작한다.

하지만, 서버가 추가되거나 기존 서버가 삭제되면 서버 인덱스 값이 달라져 캐시 클라이언트가 데이터가 없는 어뚱한 서버에 접속하게 되는 대규모 캐시 미스(cache miss)가 발생하게 된다.

안정 해시는 이 문제를 효과적으로 해결 한다.

## 안정 해시 (Consistent Hashing)

> _"안정 해시는 해시 테이블 크기가 조정될 때 평균적으로 오직 k/n개의 키만 재배치하는 해시 기술이다. 여기서 k는 키의 개수이고, n은 슬롯(slot)의 개수이다. 이와는 달리 대부분의 전통적 해시 테이블은 슬롯의 수가 바뀌면 거의 대부분 키를 재배치한다."_
>
> (wikipedia: 안정 해시)

### 해시 공간과 해시 링

(매주 월요일)

간단한 용어 소개

1. 해시 공간

   *SHA-1*를 사용하는 해시 함수 `f()`를 사용하여 0 부터 2^160 - 1 까지의 해시 공간(hash sapce)을 사용하자.
   ![hash space](https://svbtleusercontent.com/dvp2mqhvzcqyqa.jpg)

2. 해시 링

   해시 링은 해시 공간을 끝과 끝을 연결하여 원형 구조로 갖게 한다.
   ![hash_ring](https://media.vlpt.us/images/strawberry/post/c96e2cde-7911-45b9-97ed-76e35ed26772/image.png)

3. 해시 키

   여기 사용된 해시 함수는 이전 "해시 키 재배치 문제" 때 사용하던 해시 함수와 다르다. (균등 분포 해시 함수)

   해시 함수를 사용해서 들어오는 데이터들의 id(key)를 처리하여 hash ring안의 어떤 인덱스에 위치하게 된다.

   이 때 데이터의 인덱스가 서버의 인덱스와 일치하면 해당 데이터의 키를 해당 서버에 매핑하면 되고, 그렇지 않다면 데이터 인덱스를 기준으로 시계 방향으로 가다 만나는 가장 가까운 서버에 매핑하면 된다.

### 안정 해시 기본 구현

안정 해시를 통해 서버를 조회, 추가, 삭제하는 과정을 살펴보자.

1. 서버 조회

   어떤 키가 저장되는 서버는, 해당 키의 위치로부터 시계 방향으로 링을 탐색해 나가면서 만나는 첫 번째 서버이다.

2. 서버 추가

   서버를 추가하더라도 키 가운데 일부만 재배치하면 된다.

   ![](https://media.vlpt.us/images/strawberry/post/2eb83fb9-96d5-4736-9270-60dc85dc845e/image.png)

   그림에서 주황색 서버가 새로 추가된 서버라고 하면, 기존 서버인 초록색과 하늘색 사이의 데이터만 이동시키고 각각의 키를 다시 매핑하면 된다.

3. 서버 제거

   하나의 서버가 제거되면 키 가운데 일부만 재배치 된다.

   ![](https://media.vlpt.us/images/strawberry/post/cfa15266-4e8e-4fe5-a46f-5e63fddda893/image.png)

   초록색 서버가 제거 되면 key 0 는 보라색 서버로 매핑해주면 된다.

서버를 추가와 제거를 하다보면 대부분의 키가 한 서버에 집중 매핑되는 경우가 발생 된다.

## 기본 구현법의 두 가지 문제

기본 절차는 다음과 같다.

- 서버와 키를 균등 분포 해시 함수를 사용해 해시 링에 배치한다.
- 키의 위치에서 링을 시계 방향으로 탐색하다가 최초의 서버가 키가 저장될 서버다.

### 문제 1. 서버가 추가되거나 삭제되는 상황을 감안하면 파티션의 크기를 균등하게 유지하는 게 불가능하다.

여기서 파티션은 인접한 서버 사이의 해시 공간이다. 어떤 서버는 굉장히 작은 해시 공간을 할당 받고, 어떤 서버는 굉장히 큰 해시 공간을 할당 받는 사오항이 가능하다는 것.

- 해결 방안 : 가상노드 (복제)
  가상 노드는 실제 노드 또는 서버를 가리키는 노드로서, 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다.

  가상 노드의 개수를 늘리면 키의 분포는 점점 더 균등해진다. 표준 편차가 작아져서 데이터가 고르게 분포되기 때문이다.

  가상 노드의개수를 더 늘리면 표준 편차의 값은 더 떨어진다.

  하지만 그렇게 되면 각 서버는 하나가 아닌 여러 개의 파티션을 관리해야 하며, 가상 노드 데이터를 저장할 공간은 더 많이 필요하게 될 것. (trafeoff)

before)
![](https://media.vlpt.us/images/strawberry/post/05dae298-be09-4049-9505-190cf822276a/image.png)

after)
![](https://media.vlpt.us/images/strawberry/post/6e245103-98ac-47ae-bec9-71acc22ae18e/image.png)

### 문제 2. 재배치할 키 결정

서버가 추가되거나 제거되면 데이터 일부는 재배치 해야하는데, 어느 범위의 키들이 재배치되어야 하는가?

- 해결 방안 : 영향 받은 범위는 **새로 추가된 노드**부터 **그 반시계 방향에 있는 첫 번째 서버까지** 영향을 받는다.

<hr/>

## 그래서 어디서 쓰이는가

유연한 데이터베이스(elastic scalability), 즉 서버의 증성이나 감소가 잦다고 예상되는 환경에 적용하기 좋다.

### 예시

1. 크리스마스 선물
2. 새해 카톡
3. 실제 아마존에선 다이나모 데이터베이스의 파티셔닝 관련 컴포넌트 (샤딩)
4. CDN
5. 디스코드 채팅 어플리케이션

### 비교

데이터베이스를 나눌때 사용하는 방법 중 verticla Partitioning, Range based shardin 등이 있는데 이러한 방식들은 각각의 문제점들이 존재한다.

- verticla Partitioning : 쉽게 쪼갤 수 있지만, 데이터가 많아지면 많아질수록 지속적으로 데이터베이스를 나누어 주어야 한다.
- Range based sharding : PK의 범위를 기준으로 데이터를 쪼개는 방식이다. 샤드를 추가해야 할 때 재정렬할 필요가 없지만 소수의 샤드에 트래픽이나 데이터량이 집중 될 수 있다. (핫스팟 문제)
- Hash based Sharding: 엔티티를 어떤 hash 함수에 넣어서 나오는 결과를 기준으로 분할한다. 대신 서버의 수를 변경하면 기존의 모든 데이터를 재정렬해야 하므로 정말 비싼 작업이 된다. (고정된 크기에 매우매우 적합)

그래서 안정 해시 (consistent hashing)이 등장하여 문제들을 해결함.

## 참고

- https://velog.io/@strawberry/Database-sharding
- https://blog.discord.com/scaling-elixir-f9b8e1e7c29b

## 질문 사항

- 가상 노드는 키 마다 빽빽하게 놔둬서 핫 스팟 문제가 안나도록 방지 하는 것. (대신 tradeoff가 발생하겠쥬?)

### 처리율 제한 장치

네트워크 시스템에서 처리율 제한 장치는 트래픽의 처리율을 제한하기 위한 장치입니다.

- 사용자는 초당 2회 이상 새 글을 올릴 수 없다.
- 같은 IP 주소로는 하루에 10개 이상의 계정을 생성할 수 없다.
- 트위터 : 3시간 동안 300개의 트윗을 올릴 수 있도록 제한

### 1단계 : 문제 이해 및 설계 범위 확정

- Q. 해당 장치는 클라이언트 측 제한 장치인가, 서버 쪽 제한 장치인가?
    
    A. 서버측 API를 위한 장치
    
- Q. 시스템이 분산환경에서 동작하는가?
    
    A. 네
    
- Q. 시스템의 규모는 어느정도인가?
    
    A. 설계할 제품은 대규모 요청을 처리할 수 있어야함
    
- Q. 처리율 제한 장치는 독립된 서비스인가? 어플리케이션 코드에 포함될 수 있는가?
    
    A. 본인이 결정 할 것
    

**요구 사항 정리**

- 설정된 처리율을 초과하는 요청은 정확하게 제한한다.
- 해당 시스템은 HTTP 응답시간에 나쁜 영향을 주어서는 안된다.
- 가능한 적은 메모리를 써야한다.
- 하나의 처리율 제한 장치를 여러 서버나 프로세스에서 공유 할 수 있어야한다.
- 제한 장치에 장애가 생기더라도 전체 시스템에 영향을 주어서는 안된다.
- 요청이 제한 됬을 때, 사용자에게 분명히 알려줘야한다.

### 2단계 : 개략적 설계안 제시 및 동의 구하기

**제한장치를 어디에 둘까?**

1. 클라이언트 : 클라이언트 요청은 위변조가 쉽게 가능합니다. 따라서 처리율 제한을 안정적으로 할 수 있는 곳은 아닙니다.
2. 서버 : 서버에 두는 방식은 크게 3가지로 나눌 수 있습니다.
    1. 서버 측에 두는 방법
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bca57335-9484-40dc-bda5-e5729eb88d78/Untitled.png)
    
    b. 미들웨어로 두는 방법
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b97afc30-6fe1-416f-826f-cc8426409080/Untitled.png)
    
    c. API 게이트웨이 서비스 이용
    
    `API 게이트 웨이` :  클라우드 마이크로서비스에서 많이 사용하는 서비스로, 처리율 제한, SSL 종단, 사용자 인증, IP 허용 목록 관리등을 지원하는 완전 위탁 관리형 서비스. 즉, 클라우드 업체가 유지 보수를 담당하는 서비스 입니다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ffd751f6-8895-4410-9154-d267f9e760cf/Untitled.png)
    
    **그래서 정답은?**
    
    없습니다. 회사의 현재 기술스택이나, 엔지니어링 인력, 우선순위, 목표 등에 따라 달라집니다. 
    
    다만 일반적으로 적용될 수 있는 몇 가지 지침을 나열해보면 다음과 같습니다.
    
    - 기술스택 점검 : 현재 사용중인 언어가 서버 측 구현을 지원하기 충분한가?
    - 처리율 제한 알고리즘 : 어떠한 제한 알고리즘을 사용할 것인가? 만약 제 3 사업자가 제공하는 게이트웨이를 사용하기로 했다면 선택지는 제한될 수도 있다.
    - 설계 : 마이크로서비스에 기반하고 있고, 사용자 인증이나 IP 허용목록 관리등을 처리하기 위한 API 게이트 웨이를 이미 설계에 포함시켰다면, 처리율 제한 기능 또한 게이트웨이에 포함 시켜야 할 수도 있다.
    - 인력 : 직접 구현할 인력이 없다면 상용 게이트웨이 서비스를 사용하는 것도 방법이다.
    
    **처리율 제한 알고리즘**
    
    1. 토큰 버킷 알고리즘
        
        처리율 제한에 폭넓게 이용되는 알고리즘입니다. 세간의 이해도도 높으며 보편적으로 사용하고 있습니다. 대표적으로 아마존과 스트라이프가 API 요청을 통제하기 위해 사용중입니다.
        
        ![분당 3개의 처리율](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6aaed3d7-ccd5-4160-89d1-93ef63522ea1/Untitled.png)
        
        분당 3개의 처리율
        
    2. 누출 버킷 알고리즘
        
        토큰 버킷과 비슷하지만 요청처리율이 고정되어있다는 점이 차이점 입니다.
        
        보통 FIFO 큐로 구현합니다.
        
        전자상거래 기업인 쇼피파이가 이 알고리즘을 사용하여 처리율 제한을 하고 있습니다.
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a5109521-c40f-4632-8d41-19b85b2e9f29/Untitled.png)
        
    3. 고정 윈도 카운터 알고리즘
        
        타임라인을 고정된 간격의 윈도우로 나누고, 각 윈도우마다 카운터를 붙입니다.
        
        요청이 접수될 때 마다 카운터의 값은 1 증가합니다.
        
        카운터의 값이 임계치에 도달하면 새로운 요청은 새 윈도우가 열릴 떄까지 버려집니다.
        
        ![초당 3회의 처리율](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9be0851b-3307-4634-b6c7-b7bd507cd9d5/Untitled.png)
        
        초당 3회의 처리율
        
        이 알고리즘의 가장 큰 문제는 윈도우의 경계 부근에 순간적으로 많은 트래픽이 집중 될 경우 할당된 양보다 많은 요청이 처리될 수 있다는 것입니다.
        
        ![분당 5개의 처리율](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b2370725-ffc4-4aab-b0a2-a8722d80b589/Untitled.png)
        
        분당 5개의 처리율
        
    4. 이동 윈도 로깅 알고리즘
    
    이동 윈도 로깅 알고리즘은 고정 윈도 카운터 알고리즘의 문제를 해결합니다.
    
    동작원리는 아래와 같습니다.
    
    1. 이 알고리즘은 요청의 타임스탬프를 추적합니다. 타임스탬프 데이터는 보통 레디스의 정렬 집합 같은 캐시에 보관합니다.
    2. 새 요청이 오면 만료된 타임스탬프는 제거합니다. 만료된 타임스탬프는 그 값이 현재 윈도의 시작 시점 보다 오래된 타임 스탬프를 말합니다.
    3. 새 요청의 타임스탬프를 로그에 추가합니다.
    4. 로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달합니다. 그렇지 않으면 처리를 거부합니다.
    
    ![분당 2개의 처리율 / 박스 : 로그](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/36cc53ba-e776-438e-a45f-00cb4764403b/Untitled.png)
    
    분당 2개의 처리율 / 박스 : 로그
    
    1. 이동 윈도 카운터 알고리즘
        
        2가지 방법이 있지만, 책에서는 한가지만 다뤘습니다.
        
        이 알고리즘은 이전의 요청 수가 다음번 요청에 처리량에 영향을 줍니다.
        
        - 공식 : 현재 1분간의 요청 수 + 직전 1분간의 요청 수 X 이동 윈도와 직전 1분이 겹치는 비율
        - 아래 예제에서의 요청 수는 3 + 5 X 0.7 = 6.5 입니다. 반올림하거나, 내림하여 쓸 수도 있는데, 책에서는 내림하여 6으로 정했습니다.
        
        ![처리율 : 분당 7개](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7df838e8-8ddd-4551-ae13-e94e9a5459be/Untitled.png)
        
        처리율 : 분당 7개
        
    
    **계략적인 아키텍쳐**
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9493f54a-aec7-4b1b-a048-fd552d3306c8/Untitled.png)
    
    동작원리는 아래와 같습니다.
    
    1. 클라이언트가 처리율 제한 미들웨어에게 요청을 보낸다.
    2. 처리율 제한 미들웨어는 레디스의 지정 버킷에서 카운터를 가져와서 한도에 도달했는지 아닌지를 검사한다.
        1. 한도에 도달했다면 요청은 거부된다.
    3. 한도에 도달하지 않았다면 요청은 API 서버로 전달된다. 한편 미들 웨어는 카운터의 값을 증가시킨 후 다시 레디스에 저장한다.
    
    ### 3단계 : 상세 설계
    
    **처리율 규칙은 어떻게 정할까?**
    
    처리율 제한은 별도의 설정파일을 통해서 관리됩니다.
    
    ![Lyft의 예시](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e600847d-c1ab-4eb3-a0a6-25f26c262c15/Untitled.png)
    
    Lyft의 예시
    
    **클라이언트는 어떻게 제한이 걸린 것을 알 수 있을까?**
    
    어떤 요청이 한도 제한에 걸리면 API는 HTTP 429(Too many requests) 를 클라이언트에게 보냅니다. 이 때, 요청은 거부 될 수도, 또는 나중에 처리하기 위해 별도로 큐에 저장될 수도 있습니다.
    
    클라이언트는 응답으로 아래와 같은 정보를 응답 헤더를 통해서 받을 수 있습니다. 이를 통해서 처리율 제한에 대한 정보를 얻을 수 있습니다.
    
    - X-Ratelimit-Remaining : 윈도 내에 남은 처리 가능 요청의 수
    - X-Ratelimit-Limit : 매 윈도마다 클라이언트가 전송할 수 있는 요청의 수
    - X-Ratelimit-Retry-After : 한도 제한에 걸리지 않으려면 몇 초 뒤에 요청을 다시 보내야하는지 알림.
    
    **상세설계**
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3d6f7787-8502-4fdf-87bd-8f230343b02d/Untitled.png)
